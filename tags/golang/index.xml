<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on Gopherzhang</title>
    <link>https://driverzhang.github.io/tags/golang/</link>
    <description>Recent content in Golang on Gopherzhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved 2016 - 2018</copyright>
    <lastBuildDate>Mon, 02 Mar 2020 19:28:48 +0800</lastBuildDate>
    
	<atom:link href="https://driverzhang.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang生成二维码并合并海报图</title>
      <link>https://driverzhang.github.io/post/golang%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E5%90%88%E5%B9%B6%E6%B5%B7%E6%8A%A5%E5%9B%BE/</link>
      <pubDate>Mon, 02 Mar 2020 19:28:48 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E5%90%88%E5%B9%B6%E6%B5%B7%E6%8A%A5%E5%9B%BE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;项目业务中，有需求要将数据生成到二维码中，再将二维码与背景海报进行合并，当然你还可以获取微信头像嵌入到海报中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang写一个简单的键值存储系统</title>
      <link>https://driverzhang.github.io/post/golang%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 11 Feb 2020 13:37:21 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;利用 golang 中的 map 数据结构写一个带超时限制的键值存储组件&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang Gin框架中间件实现操作日志统一管理</title>
      <link>https://driverzhang.github.io/post/golang-gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 29 Nov 2019 21:11:49 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang-gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在大部分后台管理中都会出现操作日志模块的需求，一般情况你会想到创建一个操作日志表 opLog 然后就是在每个 api 的地放调用插入数据即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如上所述，这样的设计确实十分灵活可以让每个写api的开发人员自由的操作内容，但是也比较费时间和精力。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go标准库数据结构系列之堆heap</title>
      <link>https://driverzhang.github.io/post/go%E6%A0%87%E5%87%86%E5%BA%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A0%86heap/</link>
      <pubDate>Sun, 17 Nov 2019 21:59:05 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E6%A0%87%E5%87%86%E5%BA%93%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A0%86heap/</guid>
      <description>&lt;p&gt;堆 这种数据结构是比较难搞的一种，但是它在实际工程中的实用性又比较高，能够有效的解决实际中遇见的问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;那么在 go语言中是如何要实现一个heap的呢，其实在官方标准库 container/heap 已经给你实现了，你只需要根据自己实际情况进行接口实现即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang基础13问</title>
      <link>https://driverzhang.github.io/post/golang%E5%9F%BA%E7%A1%8013%E9%97%AE/</link>
      <pubDate>Sun, 25 Aug 2019 15:23:25 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%9F%BA%E7%A1%8013%E9%97%AE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近看见一篇关于go基础的问题，算是给自己的一个小考验，很多基础的东西当你回过头来看看也许有新的认识，当然这些题也适合出面试题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>记一次工程项目中goroutine引用闭包的错误操作</title>
      <link>https://driverzhang.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E4%B8%ADgoroutine%E5%BC%95%E7%94%A8%E9%97%AD%E5%8C%85%E7%9A%84%E9%94%99%E8%AF%AF%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 17 Aug 2019 13:54:13 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%B7%A5%E7%A8%8B%E9%A1%B9%E7%9B%AE%E4%B8%ADgoroutine%E5%BC%95%E7%94%A8%E9%97%AD%E5%8C%85%E7%9A%84%E9%94%99%E8%AF%AF%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;在进行敏捷开发项目中，同事写出来一些bug，其中有个goroutine引用闭包的问题，当时由于嵌入到了实际业务中相对环境较为复杂，我还没怎么注意到，后来下班地铁上就想起来了和一道经常考的面试题几乎一致。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Goroutine无法抛错就用errgroup</title>
      <link>https://driverzhang.github.io/post/goroutine%E6%97%A0%E6%B3%95%E6%8A%9B%E9%94%99%E5%B0%B1%E7%94%A8errgroup/</link>
      <pubDate>Sun, 28 Jul 2019 23:30:27 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/goroutine%E6%97%A0%E6%B3%95%E6%8A%9B%E9%94%99%E5%B0%B1%E7%94%A8errgroup/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一般在golang 中想要并发运行业务时会直接开goroutine，关键字go ,但是直接go的话函数是无法对返回数据进行处理error的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang用pprof做动态追踪和性能优化</title>
      <link>https://driverzhang.github.io/post/golang%E7%94%A8pprof%E5%81%9A%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 15 Apr 2019 21:14:27 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E7%94%A8pprof%E5%81%9A%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>&lt;p&gt;上一篇文章中用到 Jmeter 对http接口进行压力测试，虽然有一些优化但是效果不是很好，所以打算用go 的 pprof 做一个动态追踪，看看到底哪块代码比较耗性能和内存以便于进一步优化。&lt;/p&gt;

&lt;h2 id=&#34;大杀器-pprof&#34;&gt;大杀器 PProf&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang基准测试Benchmark和Jmeter压测实践</title>
      <link>https://driverzhang.github.io/post/golang%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark%E5%92%8Cjmeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 09 Apr 2019 21:42:45 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95benchmark%E5%92%8Cjmeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h1 id=&#34;golang的性能测试benchmark&#34;&gt;golang的性能测试Benchmark&lt;/h1&gt;

&lt;p&gt;go test 自带有三种测试：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;功能测试（单元测试）&lt;/li&gt;
&lt;li&gt;基准测试 （性能测试）&lt;/li&gt;
&lt;li&gt;实例测试 （举例测试）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang中的内存对齐和unsafe初探</title>
      <link>https://driverzhang.github.io/post/golang%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%92%8Cunsafe%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sun, 07 Apr 2019 14:21:21 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%92%8Cunsafe%E5%88%9D%E6%8E%A2/</guid>
      <description>&lt;h1 id=&#34;unsafe-包简单说明&#34;&gt;unsafe 包简单说明&lt;/h1&gt;

&lt;p&gt;unsafe，顾名思义，是不安全的，Go定义这个包名也是这个意思，让我们尽可能的不要使用它，如果你使用它，看到了这个名字，也会想到尽可能的不要使用它，或者更小心的使用它。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用Delve调试器在VsCode中调试Go程序</title>
      <link>https://driverzhang.github.io/post/%E7%94%A8delve%E8%B0%83%E8%AF%95%E5%99%A8%E5%9C%A8vscode%E4%B8%AD%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sun, 17 Mar 2019 22:43:57 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E7%94%A8delve%E8%B0%83%E8%AF%95%E5%99%A8%E5%9C%A8vscode%E4%B8%AD%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/</guid>
      <description>&lt;p&gt;本人平常主要是有的go代码工具是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;goland&lt;/li&gt;
&lt;li&gt;vscode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go的sync</title>
      <link>https://driverzhang.github.io/post/go%E7%9A%84sync.pool%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0/</link>
      <pubDate>Sun, 10 Mar 2019 00:26:14 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E7%9A%84sync.pool%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0/</guid>
      <description>&lt;h1 id=&#34;sync-pool临时对象池&#34;&gt;sync.Pool临时对象池&lt;/h1&gt;

&lt;p&gt;关于 pool 的由来可以参考：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/4720&#34;&gt;github issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/u/115763/blog/282376&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang内存分配逃逸分析</title>
      <link>https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 13 Feb 2019 20:01:18 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;一-golang-的内存分配逃逸-于堆和栈&#34;&gt;一. golang 的内存分配逃逸 于堆和栈&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;注意我们此处谈到的堆和栈是对操作系统中的，这个和数据结构中的堆和栈还是又一定区别的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>知识点总结</title>
      <link>https://driverzhang.github.io/post/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 06 Jan 2019 15:50:05 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;一些面试取经后自己梳理的知识点总结 &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang实现伪AI？</title>
      <link>https://driverzhang.github.io/post/golang%E5%AE%9E%E7%8E%B0%E4%BC%AAai/</link>
      <pubDate>Thu, 13 Dec 2018 22:26:00 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%AE%9E%E7%8E%B0%E4%BC%AAai/</guid>
      <description>&lt;p&gt;最近网上流传某段子，就是蹭了下当下最火的AI大法的流量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>【译】Golang友好的设计API参数可选项</title>
      <link>https://driverzhang.github.io/post/golang%E5%8F%8B%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1api%E5%8F%82%E6%95%B0%E5%8F%AF%E9%80%89%E9%A1%B9/</link>
      <pubDate>Tue, 27 Nov 2018 21:39:12 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%8F%8B%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1api%E5%8F%82%E6%95%B0%E5%8F%AF%E9%80%89%E9%A1%B9/</guid>
      <description>&lt;p&gt;最近无意间进入到一位 Go 社区大佬的博客，看见了这样一片博文，主要讲Golang的API设计特别是对于函数方法的可选参数相关的点，所以自己试着进行翻译吧。Functional options for friendly APIs &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>goroutine如何退出任务和goroutine生命周期的控制(runner并发模式)</title>
      <link>https://driverzhang.github.io/post/goroutine%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E4%BB%BB%E5%8A%A1%E5%92%8Cgoroutine%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%8E%A7%E5%88%B6runner%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 18 Nov 2018 18:58:11 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/goroutine%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E4%BB%BB%E5%8A%A1%E5%92%8Cgoroutine%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E6%8E%A7%E5%88%B6runner%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;开了goroutine如何才能退出呢？如何控制它并了解其生命周期？这里包括主动退出和外部的被动退出&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>通过channel控制goroutine数量形成协程池</title>
      <link>https://driverzhang.github.io/post/%E9%80%9A%E8%BF%87channel%E6%8E%A7%E5%88%B6goroutine%E6%95%B0%E9%87%8F%E5%BD%A2%E6%88%90%E5%8D%8F%E7%A8%8B%E6%B1%A0/</link>
      <pubDate>Wed, 31 Oct 2018 22:20:37 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E9%80%9A%E8%BF%87channel%E6%8E%A7%E5%88%B6goroutine%E6%95%B0%E9%87%8F%E5%BD%A2%E6%88%90%E5%8D%8F%E7%A8%8B%E6%B1%A0/</guid>
      <description>最近业务上需要利用大量开goroutine去并发拉取数据，但是不能无限制的 for 数据长度来开启那么多的goroutine，就要写个协程池来协调，通过channel来限制goroutine的开启数量。
业务需求： 需要生产者去每日定时拉去第三方平台数据，放入到channel缓存通道中（类型存入消息队列），消费者需要开goroutine并发的进行拉取第三方平台数据整合后再插入表中，其中goroutine开启数与channel缓存接受到的数据之间形成了协程池，从而通过了channel控制goroutine开启的数据（原理就是带缓存channel不够时会阻塞，当缓存满时也会阻塞等待消费）
代码详解：  首先声明相关变量常量等数据：  假设拉取数据可达到10W条：
const ( channelBufferSize = 1000 // channel 缓存数  goSize = 100 // 协程开启 最大数  ) // 声明一个用于定义channel的结构体 type Job struct { BucketName string // 存放 bucket 名称  Count int // 计算 重试次数 } // 全局声明该 带缓存的 channel var channlBucket = make(chan *Job, channelBufferSize)  构建生产者:
func Producer() (err error) { // 获取第三方业务相关数据,用于消费者函数调用的参数 bucketNameList, err := qiniu.GetV2sBucketNameList() if err !</description>
    </item>
    
    <item>
      <title>大厂1号面试</title>
      <link>https://driverzhang.github.io/post/%E5%A4%A7%E5%8E%821%E5%8F%B7%E9%9D%A2%E8%AF%95/</link>
      <pubDate>Mon, 15 Oct 2018 15:08:42 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E5%A4%A7%E5%8E%821%E5%8F%B7%E9%9D%A2%E8%AF%95/</guid>
      <description>&lt;p&gt;如果你觉得到了技术瓶颈，我的建议是投大厂简历然后去面试，在面试过程中你会发现你的不足。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言核心36讲 09字段的操作与约束</title>
      <link>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-09%E5%AD%97%E6%AE%B5%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Wed, 26 Sep 2018 18:46:20 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-09%E5%AD%97%E6%AE%B5%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%BA%A6%E6%9D%9F/</guid>
      <description>&lt;p&gt;字典（map）存储的不是单一值的集合，而是键值对的集合。(键 - 元素对) &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go并发编程系列01：你好,并发</title>
      <link>https://driverzhang.github.io/post/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%9701%E4%BD%A0%E5%A5%BD%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 24 Sep 2018 00:41:32 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%9701%E4%BD%A0%E5%A5%BD%E5%B9%B6%E5%8F%91/</guid>
      <description>&lt;p&gt;最近对Go语言的并发编程有一些新认识和学习，所以想记录下开了这个系列文章 &lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言核心36讲-040606程序实体</title>
      <link>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-040606%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/</link>
      <pubDate>Sat, 08 Sep 2018 14:37:53 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-040606%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BD%93/</guid>
      <description>04.05.06 | 程序实体知识点汇总 04 程序实体哪些事（上） 问题1： 声明变量有几种方式  var :=  问题解析： 考点：  #### 1. 类型推断   简单地说，类型推断是一种编程语言在编译期自动解释表达式类型的能力。
 var name = &amp;#34;zhang&amp;#34; 这里利用了 Go 语言自身的类型推断省去了 string 它只能用于对变量或常量的初始化。
 #### 2. 短变量声明用法  知识扩展 1. ==Go 语言的类型推断可以带来哪些好处==？  通过使用 Go 语言的类型推断，而节省下来的键盘敲击次数几乎可以忽略不计。但它真正的好处往往体现在我们写代码之后的事情上， 比如代码的 重构。
 重构： 通常把“不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码修改方式，叫做对该程序的重构。 重构的对象可以是一行代码、一个函数、一个功能模块，甚至一个软件系统。
package main import ( &amp;#34;flag&amp;#34; &amp;#34;fmt&amp;#34; ) func main() { var name = getTheFlag() flag.Parse() fmt.Printf(&amp;#34;Hello, %v!\n&amp;#34;, *name) } func getTheFlag() *string { return flag.</description>
    </item>
    
    <item>
      <title>goroutin 与 map 并发的采坑事件</title>
      <link>https://driverzhang.github.io/post/goroutin-%E4%B8%8E-map-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%87%87%E5%9D%91%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Tue, 28 Aug 2018 10:14:14 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/goroutin-%E4%B8%8E-map-%E5%B9%B6%E5%8F%91%E7%9A%84%E9%87%87%E5%9D%91%E4%BA%8B%E4%BB%B6/</guid>
      <description>&lt;h1 id=&#34;goroutine-与-map-并发的采坑事件&#34;&gt;goroutine 与 map 并发的采坑事件&lt;/h1&gt;

&lt;h2 id=&#34;1-goroutine-与map-的并发读写操作&#34;&gt;1. goroutine 与map 的并发读写操作&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;在Go 1.6之前， 内置的map类型是部分goroutine安全的，并发的读没有问题，并发的写可能有问题。自go 1.6之后， 并发地读写map会报错，这在一些知名的开源库中都存在这个问题，所以go 1.9之前的解决方案是额外绑定一个锁，封装成一个新的struct或者单独使用锁都可以。&lt;/p&gt;

&lt;p&gt;因为map为引用类型，所以即使函数传值调用，参数副本依然指向映射m, 所以多个goroutine并发写同一个映射m， 写过多线程程序的同学都知道，对于共享变量，资源，并发读写会产生竞争的， 故共享资源遭到破坏&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言核心36讲-02工作区和GOPATH</title>
      <link>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-02%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</link>
      <pubDate>Fri, 24 Aug 2018 11:15:02 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-02%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</guid>
      <description>&lt;h1 id=&#34;02-命令源码文件&#34;&gt;02 | 命令源码文件&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;我们已经知道，环境变量 GOPATH 指向的是一个或多个工作区，而每个工作区中都会有以代码包为基本组织形式的源码文件。&lt;/p&gt;

&lt;p&gt;这里的源码文件又分为三种，即：命令源码文件、库源码文件和测试源码文件，它们都有着不同的用途和编写规则。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;1-什么是命令源码文件-用途是什么-如何编写它&#34;&gt;1. 什么是命令源码文件，用途是什么？如何编写它&lt;/h2&gt;

&lt;h3 id=&#34;1-1-命令源码文件&#34;&gt;1.1 命令源码文件：&lt;/h3&gt;

&lt;p&gt;==命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。==&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go语言核心36讲-01工作区和GOPATH</title>
      <link>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-01%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</link>
      <pubDate>Tue, 21 Aug 2018 16:27:56 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/go%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%8336%E8%AE%B2-01%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8Cgopath/</guid>
      <description>&lt;h1 id=&#34;01-工作区和gopath&#34;&gt;01 | 工作区和GOPATH&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;说明： 该系列文章是个人购买了极客时间Go语言专栏由赫林老师著作的 Go语言核心36讲系列的个人总结归纳，算是自己对知识付费的一个负责吧。希望通过这样的笔记和该系列文章能加强自己对Go语言的核心知识的理解和运用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们去安装Go环境时都回去官网下载安装包的二进制包运行安装就可以使用了&lt;/p&gt;

&lt;p&gt;然后，解压缩包、放置目录、配置环境变量，并通过在命令行中输入：&lt;/p&gt;

&lt;p&gt;命令行运行下面命令：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 关于 nil 的认识</title>
      <link>https://driverzhang.github.io/post/golang-%E5%85%B3%E4%BA%8E-nil-%E7%9A%84%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Fri, 17 Aug 2018 16:21:09 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang-%E5%85%B3%E4%BA%8E-nil-%E7%9A%84%E8%AE%A4%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;golang-关于-nil-的认识&#34;&gt;Golang 关于 nil 的认识&lt;/h1&gt;

&lt;h2 id=&#34;1-什么是-nil&#34;&gt;1. 什么是 nil ？&lt;/h2&gt;

&lt;p&gt;大家都清楚，当你声明了一个变量 但却还并木优赋值时，golang中会自动给你的变量类型给一个对应的默认零值。这是每种类型对应的零值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;bool      -&amp;gt; false                              
numbers -&amp;gt; 0                                 
string    -&amp;gt; &amp;#34;&amp;#34;      

pointers -&amp;gt; nil
slices -&amp;gt; nil
maps -&amp;gt; nil
channels -&amp;gt; nil
functions -&amp;gt; nil
interfaces -&amp;gt; nil&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 中对请求超时设置时间</title>
      <link>https://driverzhang.github.io/post/golang-%E4%B8%AD%E5%AF%B9%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4/</link>
      <pubDate>Thu, 16 Aug 2018 18:38:58 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang-%E4%B8%AD%E5%AF%B9%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4/</guid>
      <description>&lt;h1 id=&#34;golang-中对请求超时设置时间&#34;&gt;Golang 中对请求超时设置时间&lt;/h1&gt;

&lt;p&gt;http中有Get/Post/PostForm方法&lt;/p&gt;

&lt;p&gt;可以通过http包中设置client 请求配置 ，然后通过client.Do方法实现请求&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang自学路劲资料讲解</title>
      <link>https://driverzhang.github.io/post/golang%E8%87%AA%E5%AD%A6%E8%B7%AF%E5%8A%B2%E8%B5%84%E6%96%99%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Tue, 01 May 2018 10:34:14 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E8%87%AA%E5%AD%A6%E8%B7%AF%E5%8A%B2%E8%B5%84%E6%96%99%E8%AE%B2%E8%A7%A3/</guid>
      <description>&lt;h1 id=&#34;go语言-自学讲解与资料&#34;&gt;Go语言 自学讲解与资料&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;简单说下自己情况，本人目前已有一年多开发经验（前端+后端nodejs）,再次基础上自学golang，并成功找到一家用 golang 的公司，下面开始表演真正的技术时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;各位老铁，如果你想转语言或者学习新的语言，我再这里墙裂推荐 Golang 既骚气又帅气 Google 亲儿子。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iota实例情况</title>
      <link>https://driverzhang.github.io/post/iota%E5%AE%9E%E4%BE%8B%E6%83%85%E5%86%B5/</link>
      <pubDate>Tue, 24 Apr 2018 11:48:05 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/iota%E5%AE%9E%E4%BE%8B%E6%83%85%E5%86%B5/</guid>
      <description>&lt;h1 id=&#34;iota-的一个实例&#34;&gt;iota 的一个实例&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;iota是golang语言的常量计数器,只能在常量的表达式中使用。&lt;/p&gt;

&lt;p&gt;iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用iota能简化定义，在定义枚举时很有用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>