<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础 on Gopherzhang</title>
    <link>https://driverzhang.github.io/tags/%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 基础 on Gopherzhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved 2016 - 2018</copyright>
    <lastBuildDate>Sun, 24 May 2020 22:49:54 +0800</lastBuildDate>
    
	<atom:link href="https://driverzhang.github.io/tags/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>UML时序图实践</title>
      <link>https://driverzhang.github.io/post/uml%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 24 May 2020 22:49:54 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/uml%E6%97%B6%E5%BA%8F%E5%9B%BE%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;什么是uml&#34;&gt;什么是UML&lt;/h2&gt;

&lt;p&gt;统一建模语言（Unified Modeling Language，UML）。&lt;/p&gt;

&lt;p&gt;UML 是一种编制软蓝图的标准化语言，它的目标之一就是为开发团队提供标准通用的设计语言来开发和构建计算机应用。&lt;/p&gt;

&lt;p&gt;UML 提出了一套 IT 专业人员期待多年的统一的标准建模符号。通过使用UML，这些人员能够阅读和交流系统架构和设计规划。&lt;/p&gt;

&lt;p&gt;UML支持面向对象的技术，能够准确的方便地表达面向对像的概念，体现面向对象的分析和设计风格.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang基础13问</title>
      <link>https://driverzhang.github.io/post/golang%E5%9F%BA%E7%A1%8013%E9%97%AE/</link>
      <pubDate>Sun, 25 Aug 2019 15:23:25 +0800</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang%E5%9F%BA%E7%A1%8013%E9%97%AE/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;最近看见一篇关于go基础的问题，算是给自己的一个小考验，很多基础的东西当你回过头来看看也许有新的认识，当然这些题也适合出面试题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang 关于 nil 的认识</title>
      <link>https://driverzhang.github.io/post/golang-%E5%85%B3%E4%BA%8E-nil-%E7%9A%84%E8%AE%A4%E8%AF%86/</link>
      <pubDate>Fri, 17 Aug 2018 16:21:09 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang-%E5%85%B3%E4%BA%8E-nil-%E7%9A%84%E8%AE%A4%E8%AF%86/</guid>
      <description>&lt;h1 id=&#34;golang-关于-nil-的认识&#34;&gt;Golang 关于 nil 的认识&lt;/h1&gt;

&lt;h2 id=&#34;1-什么是-nil&#34;&gt;1. 什么是 nil ？&lt;/h2&gt;

&lt;p&gt;大家都清楚，当你声明了一个变量 但却还并木优赋值时，golang中会自动给你的变量类型给一个对应的默认零值。这是每种类型对应的零值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;bool      -&amp;gt; false                              
numbers -&amp;gt; 0                                 
string    -&amp;gt; &amp;#34;&amp;#34;      

pointers -&amp;gt; nil
slices -&amp;gt; nil
maps -&amp;gt; nil
channels -&amp;gt; nil
functions -&amp;gt; nil
interfaces -&amp;gt; nil&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>域名解析cname和A记录</title>
      <link>https://driverzhang.github.io/post/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90cname%E5%92%8Ca%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 06 Aug 2018 21:25:51 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90cname%E5%92%8Ca%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h1 id=&#34;域名解析cname和a记录&#34;&gt;域名解析cname和A记录&lt;/h1&gt;

&lt;h2 id=&#34;什么是-cname&#34;&gt;什么是 cname？&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;CNAME 被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“r0WSPFSx58.”（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>架构理论学习之分布式系统理论CAP</title>
      <link>https://driverzhang.github.io/post/%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BAcap/</link>
      <pubDate>Mon, 18 Jun 2018 14:03:56 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E6%9E%B6%E6%9E%84%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BAcap/</guid>
      <description>&lt;h1 id=&#34;分布式系统理论cap&#34;&gt;分布式系统理论CAP&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;CAP 定理（CAP theorem）又被称作布鲁尔定理（Brewer&amp;rsquo;s theorem），是加州大学伯克利分校的计算机科学家埃里克·布鲁尔（Eric Brewer）在 2000 年的 ACM PODC 上提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特（Seth Gilbert）和南希·林奇（Nancy Lynch）发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;对于设计分布式系统的架构师来说-cap-是必须掌握的理论&#34;&gt;==对于设计分布式系统的架构师来说，CAP 是必须掌握的理论==。&lt;/h3&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>iota实例情况</title>
      <link>https://driverzhang.github.io/post/iota%E5%AE%9E%E4%BE%8B%E6%83%85%E5%86%B5/</link>
      <pubDate>Tue, 24 Apr 2018 11:48:05 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/iota%E5%AE%9E%E4%BE%8B%E6%83%85%E5%86%B5/</guid>
      <description>&lt;h1 id=&#34;iota-的一个实例&#34;&gt;iota 的一个实例&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;iota是golang语言的常量计数器,只能在常量的表达式中使用。&lt;/p&gt;

&lt;p&gt;iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用iota能简化定义，在定义枚举时很有用。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>golang 知识点.总结一</title>
      <link>https://driverzhang.github.io/post/golang-%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%80%BB%E7%BB%93%E4%B8%80/</link>
      <pubDate>Tue, 06 Mar 2018 00:16:33 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/golang-%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%80%BB%E7%BB%93%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;golang-知识点总结&#34;&gt;golang 知识点总结&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;此系列文档根据慕课网 golang视频总结的个模块知识点汇总。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;1-1-变量定义&#34;&gt;1.1  变量定义&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-使用-var-关键字&#34;&gt;1.1.1 使用 var 关键字&lt;/h3&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Web工作方式</title>
      <link>https://driverzhang.github.io/post/web%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 07 Feb 2018 22:51:59 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/web%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;一-web工作方式&#34;&gt;一. Web工作方式&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;我们平时浏览网页的时候,会打开浏览器，输入网址后按下回车键，然后就会显示出你想要浏览的内容。在这个看似简单的用户行为背后，到底隐藏了些什么呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>javascript事件循环解析</title>
      <link>https://driverzhang.github.io/post/javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 22 Nov 2017 14:00:59 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h1 id=&#34;javascript-事件循环解析&#34;&gt;javascript 事件循环解析&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;用几张图来示意了解一下 事件循环和异步调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;先来个简单的-ajax-异步&#34;&gt;先来个简单的 ajax 异步&lt;/h2&gt;

&lt;p&gt;让我们来看看下面的例子:&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>void 0</title>
      <link>https://driverzhang.github.io/post/void-0/</link>
      <pubDate>Fri, 17 Nov 2017 14:20:37 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/void-0/</guid>
      <description>&lt;h1 id=&#34;void-0-代替-undefined&#34;&gt;void 0 代替 undefined&lt;/h1&gt;

&lt;h2 id=&#34;why&#34;&gt;why?&lt;/h2&gt;

&lt;p&gt;首先说下 undefined 的一些不好的地方：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JS原型和继承</title>
      <link>https://driverzhang.github.io/post/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sat, 21 Oct 2017 21:25:17 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/js%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</guid>
      <description>&lt;h1 id=&#34;js原型与继承&#34;&gt;JS原型与继承&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;首先原型和继承在 JavaScript 中一直都是比较核心重点并且难点的理论，今天我们就来看看其中的奥秘点，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;1-开篇&#34;&gt;1. 开篇&lt;/h2&gt;

&lt;p&gt;先看如下代码出自 JavaScript 高级程序设计第三版 P163：&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>getQueryStringArgs</title>
      <link>https://driverzhang.github.io/post/getquerystringargs/</link>
      <pubDate>Sat, 21 Oct 2017 21:02:17 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/getquerystringargs/</guid>
      <description>&lt;h1 id=&#34;getquerystringargs&#34;&gt;getQueryStringArgs&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>this 豁然开朗！</title>
      <link>https://driverzhang.github.io/post/this-%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97/</link>
      <pubDate>Mon, 16 Oct 2017 13:33:07 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/this-%E8%B1%81%E7%84%B6%E5%BC%80%E6%9C%97/</guid>
      <description>&lt;h1 id=&#34;this-豁然开朗的四种规则&#34;&gt;this 豁然开朗的四种规则&lt;/h1&gt;

&lt;h3 id=&#34;调用点-call-site&#34;&gt;调用点（call-site）&lt;/h3&gt;

&lt;blockquote&gt;
&lt;h4 id=&#34;调用点-找到一个函数是在哪里被调用的-但不总是那么简单-比如某些特定的编码模式会使-真正的-调用点变得不那么明确&#34;&gt;调用点：“找到一个函数是在哪里被调用的”，但不总是那么简单，比如某些特定的编码模式会使 真正的 调用点变得不那么明确。&lt;/h4&gt;

&lt;h3 id=&#34;调用栈-call-stack&#34;&gt;调用栈（call-stack）&lt;/h3&gt;

&lt;h4 id=&#34;调用栈-使我们到达当前执行位置而被调用的所有方法的堆栈&#34;&gt;调用栈：使我们到达当前执行位置而被调用的所有方法的堆栈。&lt;/h4&gt;

&lt;p&gt;我们来展示一下调用栈和调用点：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>TJS转化大写</title>
      <link>https://driverzhang.github.io/post/js%E8%BD%AC%E5%8C%96%E5%A4%A7%E5%86%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/js%E8%BD%AC%E5%8C%96%E5%A4%A7%E5%86%99/</guid>
      <description>&lt;h1 id=&#34;用js转化大写-98-的都前端同学都没作出来&#34;&gt;用JS转化大写，98%的都前端同学都没作出来！&lt;/h1&gt;

&lt;h3 id=&#34;题目-使用javascript-将字符串中由空格隔开的每个单词-首字-母大写-写出通用方法&#34;&gt;题目：使用JavaScript 将字符串中由空格隔开的每个单词 &lt;strong&gt;首字&lt;/strong&gt; 母大写，写出通用方法。&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;题目解释：&lt;/p&gt;

&lt;p&gt;原始字符串: var string =”I believe I am the best”&lt;br /&gt;
通过您的方法得到后的结果:string 的值为”I Believe I Am The Best”.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>addLoadEvent自定义方法</title>
      <link>https://driverzhang.github.io/post/onload%E4%BA%8B%E4%BB%B6-----addloadevent%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/onload%E4%BA%8B%E4%BB%B6-----addloadevent%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h1 id=&#34;自定义方法-addloadevent&#34;&gt;自定义方法 addLoadEvent&lt;/h1&gt;

&lt;p&gt;假如我们希望某个函数在网页加载完毕之后就立即执行。网页加载完毕时会触发一个onload事件，所以我们可以利用onload事件来加载这个函数。Onload事件与window对象相关联。

如：把myfunction函数绑定到这个事件上：&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>arguments系列问题</title>
      <link>https://driverzhang.github.io/post/arguments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/arguments/</guid>
      <description>arguments、arguments.callee、arguments.caller的关系和区别 JS高三教程（P177），一段代码中用到了arguments.callee来调用函数自生，书中介绍到 “是一个指向正在执行的函数的指针，可以用它来实现对函数的递归调用。”
这段递归调用代码如下：
function factorial (num) { if (num &amp;lt;= 1) { return 1; } else { return num * arguments.callee(num - 1); } } var num = factorial(10); console.log(num); // =&amp;gt; 3628800  很简单的一段代码。于是自己为了搞清楚知识点，加强自身JS基础，就自己查了下文档  arguments arguments.callee arguments.caller  三者的关系与区别： arguments:  在函数调用时， 会自动在该函数内部生成一个名为 arguments的隐藏对象。 该对象类似于数组， 但又不是数组。可以使用[]操作符获取函数调用时传递的实参。
 arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。 没错它是个对象！并且它存储的是实际传递给函数的参数
function obj(){ //利用instanceof判断arguments  console.log( &amp;#39;arguments instanceof Array? &amp;#39; + (arguments instanceof Array) ); // =&amp;gt; false  console.</description>
    </item>
    
    <item>
      <title>面试总结一</title>
      <link>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80/</guid>
      <description>&lt;h1 id=&#34;面试总结一&#34;&gt;面试总结一&lt;/h1&gt;

&lt;h2 id=&#34;box-sizing-常用的属性有哪些-分别什么作用&#34;&gt;box-sizing 常用的属性有哪些？分别什么作用？&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;我们平时用div的盒子理论时，定义的 width 只为 content 内容。但是并不包括周边的 border 和 padding 部分。&lt;/p&gt;

&lt;p&gt;那么如果我们想直接对整个盒子进行设置布局就可以使用 box-sizing 了。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>面试总结三</title>
      <link>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%89/</guid>
      <description>&lt;h1 id=&#34;面试总结三&#34;&gt;面试总结三&lt;/h1&gt;

&lt;h2 id=&#34;一道闭包经典面试题&#34;&gt;一道闭包经典面试题：&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;这道题很经典，对于理解闭包很到位，并且还可以稳固js 的词法作用域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>面试总结二</title>
      <link>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%BA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://driverzhang.github.io/post/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%BA%8C/</guid>
      <description>&lt;h1 id=&#34;面试总结二&#34;&gt;面试总结二&lt;/h1&gt;

&lt;h1 id=&#34;css常见兼容问题&#34;&gt;css常见兼容问题&lt;/h1&gt;

&lt;h3 id=&#34;1-浏览器默认的margin和padding不同&#34;&gt;1. 浏览器默认的margin和padding不同：&lt;/h3&gt;</description>
    </item>
    
  </channel>
</rss>